<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Water Environment - IxU Reflected</title><meta name="description" content="Table of ContentsWeek 8Week 7Week 6Week 5Week 4Latest Arduino CodeWeek 8Wiring of LEDs acting in place of magenta pump (red), yellow pump (yellow), and remove water pump (blue), as well as manula on/off buttonWiring of add/remove water pump to L293D (yellow wire to D9 to orange wire to D10)Wiring of magenta and yellow pumps on L293D, as well as add/remove water pumps represented by LEDs (blue) and manual on/off buttonAnother view of wiring of magenta and yellow pumps on L293D, as well as add/remove water pumps represented by LEDs (blue) and manual on/off buttonMagenta and yellow pumps (wired to L293D) after running to max magenta pump speedMagenta dye after adding a different water to refill it (Turning pink to purple)Dye drain after running magenta pump to max speed at the same time as yellow pump runningMagenta and yellow dyes mixingMagical natural food coloring visual of magenta/purple dye.Mixed coloring of equal parts magenta and yellowMixed coloring of equal parts magenta and yellowVideo of testing magenta and yellow pumps running and add/remove water pump.Week 7Left cup shows water drained by magenta pump running until max speed. Right cup shows original water level before running pump.Liquid moved into a larger container from magenta pump running until max speed.MB1260 Ultrasonic sensor used to test water level detection. (Not videoed)Prototype Build Ideating (Page 1)Prototype Build Ideating (Page 2)Prototype Build Ideating (Page 3)Prototype Build Ideating (Page 4)Prototype Build Ideating (Page 5)Prototype Build Ideating (Page 6)Wiring for two LEDs (acting in place on pumps' engage pins) and on/off buttonVideo of LED-tested two-pump behavior with manual system on/off button.Major changes:Planning to use short-range ultrasonic sensor for measuring water level instead of calculating in program due to challenging variables in calculating water volume vs. water level mathematically (different shapes of tanks, unideal variations in pumps running).Planning to use long-range ultrasonic sensor for detecting proximity of people in the gallery space (for affecting socialization factor/variable) instead of capacitive sensor because it would be more straightforward and precise.Week 6LED with PWM (corresponding to pump speed) set around 100 (in range 0 to 255)LED with PWM (corresponding to pump speed) set around 160 (in range 0 to 255)LED with PWM (corresponding to pump speed) set at 255 (in range 0 to 255)Video of LED-tested incrementing PWM output and code for continuous pump running.Major Change: Shifting code from custom libraries to all written in Arduino IDE with non-blocking delays and continuously running pumps.Week 5Water Cup vs. Dye Cup after program ran for 4 minutes.Circuit for Pump and LED (acting in place of a second pump).Week 5 Code Progress tested on one pump and one LED acting in place of a second pump.Week 4PIR sensor and two LEDs in place of two pumps. Red LED turns on when PIR senses motion, blue LED when not.Code print statements for turning pumps on and off in response to PIR state.Circuit progress for one pump controlled by an L293D.Pump incrementally turns up its speed based on PIR sensor input, stays on for a period of time to add the liquid (to-be dye), then decrements to turn off.Latest Arduino Code"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://n-katty-kat.github.io/ixu-reflected/water-environment.html"><link rel="alternate" type="application/atom+xml" href="https://n-katty-kat.github.io/ixu-reflected/feed.xml" title="IxU Reflected - RSS"><link rel="alternate" type="application/json" href="https://n-katty-kat.github.io/ixu-reflected/feed.json" title="IxU Reflected - JSON"><meta property="og:title" content="Water Environment"><meta property="og:site_name" content="IxU Reflected"><meta property="og:description" content="Table of ContentsWeek 8Week 7Week 6Week 5Week 4Latest Arduino CodeWeek 8Wiring of LEDs acting in place of magenta pump (red), yellow pump (yellow), and remove water pump (blue), as well as manula on/off buttonWiring of add/remove water pump to L293D (yellow wire to D9 to orange wire to D10)Wiring of magenta and yellow pumps on L293D, as well as add/remove water pumps represented by LEDs (blue) and manual on/off buttonAnother view of wiring of magenta and yellow pumps on L293D, as well as add/remove water pumps represented by LEDs (blue) and manual on/off buttonMagenta and yellow pumps (wired to L293D) after running to max magenta pump speedMagenta dye after adding a different water to refill it (Turning pink to purple)Dye drain after running magenta pump to max speed at the same time as yellow pump runningMagenta and yellow dyes mixingMagical natural food coloring visual of magenta/purple dye.Mixed coloring of equal parts magenta and yellowMixed coloring of equal parts magenta and yellowVideo of testing magenta and yellow pumps running and add/remove water pump.Week 7Left cup shows water drained by magenta pump running until max speed. Right cup shows original water level before running pump.Liquid moved into a larger container from magenta pump running until max speed.MB1260 Ultrasonic sensor used to test water level detection. (Not videoed)Prototype Build Ideating (Page 1)Prototype Build Ideating (Page 2)Prototype Build Ideating (Page 3)Prototype Build Ideating (Page 4)Prototype Build Ideating (Page 5)Prototype Build Ideating (Page 6)Wiring for two LEDs (acting in place on pumps' engage pins) and on/off buttonVideo of LED-tested two-pump behavior with manual system on/off button.Major changes:Planning to use short-range ultrasonic sensor for measuring water level instead of calculating in program due to challenging variables in calculating water volume vs. water level mathematically (different shapes of tanks, unideal variations in pumps running).Planning to use long-range ultrasonic sensor for detecting proximity of people in the gallery space (for affecting socialization factor/variable) instead of capacitive sensor because it would be more straightforward and precise.Week 6LED with PWM (corresponding to pump speed) set around 100 (in range 0 to 255)LED with PWM (corresponding to pump speed) set around 160 (in range 0 to 255)LED with PWM (corresponding to pump speed) set at 255 (in range 0 to 255)Video of LED-tested incrementing PWM output and code for continuous pump running.Major Change: Shifting code from custom libraries to all written in Arduino IDE with non-blocking delays and continuously running pumps.Week 5Water Cup vs. Dye Cup after program ran for 4 minutes.Circuit for Pump and LED (acting in place of a second pump).Week 5 Code Progress tested on one pump and one LED acting in place of a second pump.Week 4PIR sensor and two LEDs in place of two pumps. Red LED turns on when PIR senses motion, blue LED when not.Code print statements for turning pumps on and off in response to PIR state.Circuit progress for one pump controlled by an L293D.Pump incrementally turns up its speed based on PIR sensor input, stays on for a period of time to add the liquid (to-be dye), then decrements to turn off.Latest Arduino Code"><meta property="og:url" content="https://n-katty-kat.github.io/ixu-reflected/water-environment.html"><meta property="og:type" content="article"><link rel="preload" href="https://n-katty-kat.github.io/ixu-reflected/assets/dynamic/fonts/robotoflex/robotoflex.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://n-katty-kat.github.io/ixu-reflected/assets/dynamic/fonts/robotoslab/robotoslab.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://n-katty-kat.github.io/ixu-reflected/assets/css/style.css?v=f6bdb60e55e38d9674e50e2698bccd14"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://n-katty-kat.github.io/ixu-reflected/water-environment.html"},"headline":"Water Environment","datePublished":"2025-02-03T16:29-08:00","dateModified":"2025-03-03T11:31-08:00","description":"Table of ContentsWeek 8Week 7Week 6Week 5Week 4Latest Arduino CodeWeek 8Wiring of LEDs acting in place of magenta pump (red), yellow pump (yellow), and remove water pump (blue), as well as manula on/off buttonWiring of add/remove water pump to L293D (yellow wire to D9 to orange wire to D10)Wiring of magenta and yellow pumps on L293D, as well as add/remove water pumps represented by LEDs (blue) and manual on/off buttonAnother view of wiring of magenta and yellow pumps on L293D, as well as add/remove water pumps represented by LEDs (blue) and manual on/off buttonMagenta and yellow pumps (wired to L293D) after running to max magenta pump speedMagenta dye after adding a different water to refill it (Turning pink to purple)Dye drain after running magenta pump to max speed at the same time as yellow pump runningMagenta and yellow dyes mixingMagical natural food coloring visual of magenta/purple dye.Mixed coloring of equal parts magenta and yellowMixed coloring of equal parts magenta and yellowVideo of testing magenta and yellow pumps running and add/remove water pump.Week 7Left cup shows water drained by magenta pump running until max speed. Right cup shows original water level before running pump.Liquid moved into a larger container from magenta pump running until max speed.MB1260 Ultrasonic sensor used to test water level detection. (Not videoed)Prototype Build Ideating (Page 1)Prototype Build Ideating (Page 2)Prototype Build Ideating (Page 3)Prototype Build Ideating (Page 4)Prototype Build Ideating (Page 5)Prototype Build Ideating (Page 6)Wiring for two LEDs (acting in place on pumps' engage pins) and on/off buttonVideo of LED-tested two-pump behavior with manual system on/off button.Major changes:Planning to use short-range ultrasonic sensor for measuring water level instead of calculating in program due to challenging variables in calculating water volume vs. water level mathematically (different shapes of tanks, unideal variations in pumps running).Planning to use long-range ultrasonic sensor for detecting proximity of people in the gallery space (for affecting socialization factor/variable) instead of capacitive sensor because it would be more straightforward and precise.Week 6LED with PWM (corresponding to pump speed) set around 100 (in range 0 to 255)LED with PWM (corresponding to pump speed) set around 160 (in range 0 to 255)LED with PWM (corresponding to pump speed) set at 255 (in range 0 to 255)Video of LED-tested incrementing PWM output and code for continuous pump running.Major Change: Shifting code from custom libraries to all written in Arduino IDE with non-blocking delays and continuously running pumps.Week 5Water Cup vs. Dye Cup after program ran for 4 minutes.Circuit for Pump and LED (acting in place of a second pump).Week 5 Code Progress tested on one pump and one LED acting in place of a second pump.Week 4PIR sensor and two LEDs in place of two pumps. Red LED turns on when PIR senses motion, blue LED when not.Code print statements for turning pumps on and off in response to PIR state.Circuit progress for one pump controlled by an L293D.Pump incrementally turns up its speed based on PIR sensor input, stays on for a period of time to add the liquid (to-be dye), then decrements to turn off.Latest Arduino Code","author":{"@type":"Person","name":"Aleena Jett","url":"https://n-katty-kat.github.io/ixu-reflected/authors/aleena-jett/"},"publisher":{"@type":"Organization","name":"Aleena Jett"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><header class="top js-header"><a class="logo" href="https://n-katty-kat.github.io/ixu-reflected/">IxU Reflected</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://n-katty-kat.github.io/ixu-reflected/" target="_self">IxU Reflected</a></li><li class="active-parent has-submenu"><a href="https://n-katty-kat.github.io/ixu-reflected/progress.html" target="_self" aria-haspopup="true">Progress</a><ul class="navbar__submenu level-2" aria-hidden="true"><li class="active"><a href="https://n-katty-kat.github.io/ixu-reflected/water-environment.html" target="_self">Water Environment</a></li><li><a href="https://n-katty-kat.github.io/ixu-reflected/cluster-animation.html" target="_self">Cluster Animation</a></li></ul></li><li><a href="https://n-katty-kat.github.io/ixu-reflected/ixu-reflected-2.html" target="_self">Concept and Lineage</a></li><li><a href="https://n-katty-kat.github.io/ixu-reflected/getting-technical.html" target="_self">Getting Technical</a></li><li><a href="https://n-katty-kat.github.io/ixu-reflected/about-me.html" target="_self">About Me</a></li></ul></nav></header><main class="page"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Water Environment</h1></div></header></div><div class="entry-wrapper content__entry"><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1ildb1abhl6">Week 8</a></li><li><a href="#mcetoc_1ildb1abhl7">Week 7</a></li><li><a href="#mcetoc_1ildb1abhl8">Week 6</a></li><li><a href="#mcetoc_1ildb1abhl9">Week 5</a></li><li><a href="#mcetoc_1ildb1abhla">Week 4</a></li><li><a href="#mcetoc_1ildbembnm9">Latest Arduino Code</a></li></ul></div><h3 id="mcetoc_1ildb1abhl6">Week 8</h3><div class="gallery-wrapper"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="3"><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250225_194418.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250225_194418-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Wiring of LEDs acting in place of magenta pump (red), yellow pump (yellow), and remove water pump (blue), as well as manula on/off button</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_141939.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_141939-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Wiring of add/remove water pump to L293D (yellow wire to D9 to orange wire to D10)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_160958.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_160958-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Wiring of magenta and yellow pumps on L293D, as well as add/remove water pumps represented by LEDs (blue) and manual on/off button</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_164029.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_164029-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Another view of wiring of magenta and yellow pumps on L293D, as well as add/remove water pumps represented by LEDs (blue) and manual on/off button</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_160955.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_160955-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Magenta and yellow pumps (wired to L293D) after running to max magenta pump speed</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_160644.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_160644-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Magenta dye after adding a different water to refill it (Turning pink to purple)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_161056.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_161056-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Dye drain after running magenta pump to max speed at the same time as yellow pump running</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_161207.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_161207-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Magenta and yellow dyes mixing</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_161442.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_161442-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Magical natural food coloring visual of magenta/purple dye.</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_162455.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_162455-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Mixed coloring of equal parts magenta and yellow</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_162502.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250228_162502-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Mixed coloring of equal parts magenta and yellow</figcaption></figure></div></div><p class="align-center"></p><div class="post__iframe"><iframe loading="lazy" width="699" height="393" style="width: 699px; height: 393px;" src="https://www.youtube.com/embed/Z3xXyswdRfc?si=xPZn0Uaet6MWY7yP" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="allowfullscreen"></iframe></div>Video of testing magenta and yellow pumps running and add/remove water pump.<p></p><h3 id="mcetoc_1ildb1abhl7">Week 7</h3><div class="gallery-wrapper gallery-wrapper--wide"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="3"><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250217_134408.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250217_134408-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Left cup shows water drained by magenta pump running until max speed. Right cup shows original water level before running pump.</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250217_134410.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250217_134410-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Liquid moved into a larger container from magenta pump running until max speed.</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250224_181507.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250224_181507-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>MB1260 Ultrasonic sensor used to test water level detection. (Not videoed)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto1.jpg" data-size="1668x2157"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto1-thumbnail.jpg" alt="" width="720" height="931"></a><figcaption>Prototype Build Ideating (Page 1)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto2.jpg" data-size="1668x2157"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto2-thumbnail.jpg" alt="" width="720" height="931"></a><figcaption>Prototype Build Ideating (Page 2)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto3.jpg" data-size="1668x2157"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto3-thumbnail.jpg" alt="" width="720" height="931"></a><figcaption>Prototype Build Ideating (Page 3)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto4.jpg" data-size="1668x2157"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto4-thumbnail.jpg" alt="" width="720" height="931"></a><figcaption>Prototype Build Ideating (Page 4)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto5.jpg" data-size="1668x2157"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto5-thumbnail.jpg" alt="" width="720" height="931"></a><figcaption>Prototype Build Ideating (Page 5)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto6.jpg" data-size="1668x2157"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/proto6-thumbnail.jpg" alt="" width="720" height="931"></a><figcaption>Prototype Build Ideating (Page 6)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250217_181828.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250217_181828-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Wiring for two LEDs (acting in place on pumps' engage pins) and on/off button</figcaption></figure></div></div><p class="align-center"></p><div class="post__iframe"><iframe loading="lazy" width="699" height="393" style="width: 699px; height: 393px;" src="https://www.youtube.com/embed/df7AiC6FVM4?si=UaUlYecbAx5kr9Pe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="allowfullscreen"></iframe></div>Video of LED-tested two-pump behavior with manual system on/off button.<p></p><p>Major changes:</p><ol style="list-style-type: lower-roman;"><li>Planning to use short-range ultrasonic sensor for measuring water level instead of calculating in program due to challenging variables in calculating water volume vs. water level mathematically (different shapes of tanks, unideal variations in pumps running).</li><li>Planning to use long-range ultrasonic sensor for detecting proximity of people in the gallery space (for affecting socialization factor/variable) instead of capacitive sensor because it would be more straightforward and precise.</li></ol><h3 id="mcetoc_1ildb1abhl8">Week 6</h3><div class="gallery-wrapper gallery-wrapper--wide"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="3"><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250216_202643.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250216_202643-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>LED with PWM (corresponding to pump speed) set around 100 (in range 0 to 255)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250216_202708.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250216_202708-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>LED with PWM (corresponding to pump speed) set around 160 (in range 0 to 255)</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250216_202845.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250216_202845-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>LED with PWM (corresponding to pump speed) set at 255 (in range 0 to 255)</figcaption></figure></div></div><p class="align-center"></p><div class="post__iframe"><iframe loading="lazy" width="699" height="393" style="width: 699px; height: 393px;" src="https://www.youtube.com/embed/bWAA9ZK9SQs?si=gXNybugBdXtoTT0x" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="allowfullscreen"></iframe></div>Video of LED-tested incrementing PWM output and code for continuous pump running.<p></p><p>Major Change: Shifting code from custom libraries to all written in Arduino IDE with non-blocking delays and continuously running pumps.</p><h3 id="mcetoc_1ildb1abhl9">Week 5</h3><div class="gallery-wrapper gallery-wrapper--wide"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="2"><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250204_195245.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250204_195245-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Water Cup vs. Dye Cup after program ran for 4 minutes.</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250204_194101.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/20250204_194101-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Circuit for Pump and LED (acting in place of a second pump).</figcaption></figure></div></div><p class="align-center"></p><div class="post__iframe"><iframe loading="lazy" width="721" height="403" style="width: 709px; height: 396px;" src="https://www.youtube.com/embed/9yi13J8juxU?si=haHWfO5daVq2ItJy" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="allowfullscreen"></iframe></div>Week 5 Code Progress tested on one pump and one LED acting in place of a second pump.<p></p><h3 id="mcetoc_1ildb1abhla">Week 4</h3><div class="gallery-wrapper gallery-wrapper--wide"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="3"><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/2lights.jpg" data-size="3000x4000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/2lights-thumbnail.jpg" alt="" width="720" height="960"></a><figcaption>PIR sensor and two LEDs in place of two pumps. Red LED turns on when PIR senses motion, blue LED when not.</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/codeexample.jpg" data-size="4000x3000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/codeexample-thumbnail.jpg" alt="" width="720" height="540"></a><figcaption>Code print statements for turning pumps on and off in response to PIR state.</figcaption></figure><figure class="gallery__item"><a href="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/pumpandpir.jpg" data-size="3000x4000"><img loading="lazy" src="https://n-katty-kat.github.io/ixu-reflected/media/posts/12/gallery/pumpandpir-thumbnail.jpg" alt="" width="720" height="960"></a><figcaption>Circuit progress for one pump controlled by an L293D.</figcaption></figure></div></div><p class="align-center"></p><div class="post__iframe"><iframe loading="lazy" width="624" height="351" style="width: 702px; height: 394px;" src="https://www.youtube.com/embed/N2Yv9IMuCYY?si=AA9iJsNLDw_CzbVC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="allowfullscreen"></iframe></div>Pump incrementally turns up its speed based on PIR sensor input, stays on for a period of time to add the liquid (to-be dye), then decrements to turn off.<p></p><h3 id="mcetoc_1ildbembnm9">Latest Arduino Code</h3><pre class="language-cpp"><code>// from SafeString V3 library https://www.forward.com.au/pfod/ArduinoProgramming/TimingDelaysInArduino.html#examples
#include "loopTimer.h"
#include "millisDelay.h"
#include "BufferedOutput.h"
// https://youtu.be/lqg_Ze_OiiY?si=H7TvYJQIvozWl-Bi
#include "CapacitiveSensor.h" // or &lt;CapacitiveSensor.h&gt; ?
createBufferedOutput(bufferedOut, 80, DROP_UNTIL_EMPTY); // buffered use and loop timer from https://www.instructables.com/Simple-Multi-tasking-in-Arduino-on-Any-Board/

// --------VARIABLES/OBJECTS--------
// PAUSE BUTTON
#define PAUSEBUTTON 13
bool programRunning = true;

// EMERGENCY WATER LEVEL SENSOR using sonar? or another sensor as backup
/*
#define WATERLVLPIN 4
// no delay, just constantly run for readings unless need a delay for any built in delays
int waterLvlVal = 0; // need to calibrate to the current environ, any amount of resistance detection counted as actual water touching is sign that program needs to stop
*/

// PIR &amp; SONAR PPL DETECT
#define PIRPIN 12 // sensor input
// millisDelay pirDelay; // 
// const int PIRDELAYTIME = 8000; // timedelay+nonreadingdelay (~5s+3s)
int pirSonarInfo[2] = {-1,-1}; // holding whether PIR reads H or L, no new reading is set to -1
millisDelay pirSonarDelay;
const int PIRSONARDELAYTIME = 8000; // timedelay of pir+nonreading delay of pir
// SONAR PPL DETECT
#define PPLSONARPIN A2
// millisDelay pplSonarDelay;
// const int PPLSONARDELAYTIME = 2000; // allow to adjust socialize var even if PIR state is still a prior state but ur then i need to know the prior PIR so maybe i align w PIR unless direct touch
  // ex: 8000 ms delay to match w PIRDELAYTIME
// usually direct touch is around 10k return value
int pplSonarDistancein = -1; // default val
int closePplDistance = 6; //min is 6in measure as closest; max is 254in
  // if it got too close and interactive, i think itd be interesting if it shut off bc it was shy
int midPplDistance = 111; // measure by which positive effect can be had
  // table to door 72*3+12 = 19ft (228in)
  // (228in(dist to door)-6in (min))/2 (middle)

// WATER LEVEL - Sonar
// mb1644 shortrange ; 2-50cm
#define WATERSONARPIN A1
millisDelay waterSonarDelay;
const int WATERSONARDELAYTIME = 200; // ms, adjust, mb1644 has 100ms read speed, relatively frequent to take note on water level for safety too
int waterSonarDistancemm = 0; // can't measure less than like 5-6in so 0 would be a non-read value
int farthestDistanceToWater = 200; //mm; for lowest water level, larger dist to water top
int closestDistanceToWater = 50; //mm; for highest water level, smaller dist to water top
int midWaterDistance = 75; // mm; middle of high and low

// FLOAT
#define FLOATPIN A0
millisDelay floatDelay; // just to give some delay between readings so it isn't read too frequently
const int FLOATDELAYTIME = 4000; // ms; arbitrary --&gt; pump needs enough time w a fixed value to actually move water so do a longer delay (based on how the updateCreate func works), whatever works best for the program in consideration of readings being continous for x time before a new reading
int floatDiff = 1024; // the val and threshold is decided in the reading function, only the difference needs to be known globally; tho the threshold could be reflected too somehow

// CONTINUOUS PUMPS
const int MINPUMPSPEED = 85;
const int INCDELAY = 5; // ms

// MAGENTA
#define MAGENTAPIN 3
millisDelay magentaIncDelay;
int magentaSpeed = 0;
int magentaEnVal = 0;

// CYAN
#define CYANPIN 5
millisDelay cyanIncDelay;
int cyanSpeed = 0;
int cyanEnVal = 0;

// YELLOW
#define YELLOWPIN 6
millisDelay yellowIncDelay;
int yellowSpeed = 0;
int yellowEnVal = 0;

// REMOVAL/ADD
#define WATERADDIN 9
#define WATERRMVIN 10
millisDelay waterIncDelay;
int waterSpeed = 0;
// alt option is 3 pins w inputs on reg high low and engage on pwm
int waterAddInVal = 0; // input 1 reg polarity pos
int waterRmvInVal = 0; // input 2 reverse polarity pos
bool removeWater = true; // change for min/max and basic removal stuff

// BEHAVIORS - set a baseline defined by its min/max range
// extremes
millisDelay extremeBlockDelay;
// const int SOCMAXDELAYTIME = (INCDELAY*255*2) + 5000; // ms, time to change regular water removal up to 255, plus time calculated based on volume to remove, plus time to slow back down to 0? or average removal speed
bool socMaxActive = false;
// bool socMinActive = false;
// bool hydLowActive = false;
// bool hydHighActive = false;
// bool creMaxActive = false;
// bool creMinActive = false;
// const int SOCMINDELAYTIME = (INCDELAY*255*2) + 5000; //ms
// const int HYDLOWDELAYTIME = (INCDELAY*255*2) + 5000;
// const int HYDHIGHDELAYTIME = (INCDELAY*255*2) + 5000;
// const int CREMAXDELAYTIME = (INCDELAY*255*2) + 5000;
// const int CREMINDELAYTIME = (INCDELAY*255*2) + 5000;

const int SOCIALIZERANGE = 1000; // 0 to 3000; 1/3 of the value is the min to turn on the pump (map to 85)
const int BASESOCIALIZE = (SOCIALIZERANGE / 4); // base value to ref elsewhere in program; base level should always be below 1/3 of the total range to start all the pumps OFF
int socialize = BASESOCIALIZE; // **(need to adjust) baseline start (having smth to gain or lose) ; mapped to magenta
// bool sociallyDrained = false; // max socialize value hit
// millisDelay socialDrainBlockDelay; // prevent updateSocialize() from changing socialize var after maximum socialize val is reached for a time
// const int SOCIALDRAINBLOCKTIME = 5000; // adjust time to go based on if the removal of water has finished or not [basically whichever is longer will allow socialize to be changed again]
// bool lonely = false; // min socialize value hit
// millisDelay lonelyBlockDelay;
// const int LONELYBLOCKTIME = 5000; // again, adjust and consider compared to time for other aspects of the drain to occur first with other delays or booleans (whatever is most appropriate)

int hydrate = 0; // mapped to cyan

int create = 0; // mapped to yellow; 0 is neutral state (not above or below floatDiff threshold)
const int ANALOGMAX = 1023; // max possible value to come from analog pin input sensing

void setup() {

  Serial.begin(9600);
  // pause button setup
  pinMode(PAUSEBUTTON, INPUT_PULLUP);

  // emergency water level sensor setup

  // seed for random values
  pinMode(FLOATPIN, INPUT); // do i need to set this as input?
  randomSeed(analogRead(FLOATPIN));
  floatDelay.start(FLOATDELAYTIME); // needs to already be timed out upon first loop run

  // magenta pump setup
  pinMode(MAGENTAPIN, OUTPUT);
  analogWrite(MAGENTAPIN, 0);

  // cyan pump setup
  // pinMode(CYANPIN, OUTPUT);
  // analogWrite(CYANPIN, 0);

  // yellow pump setup
  pinMode(YELLOWPIN, OUTPUT);
  analogWrite(YELLOWPIN, 0);

  // water pump setup
  pinMode(WATERADDIN, OUTPUT);
  analogWrite(WATERADDIN, 0);
  pinMode(WATERRMVIN, OUTPUT);
  analogWrite(WATERRMVIN, 0);

  // ultrasonic sensor setup
  pinMode(WATERSONARPIN, INPUT);
  waterSonarDelay.start(WATERSONARDELAYTIME);
  // need a calibration period to determine the min and max height measures
    // also i think its +/- 5mm error margin??? or smth - see docs
    // while(button not pressed){don't pass} --&gt; button pressed do read for indicated level (lowest), do twice, go w higher reading; repeat while then until measured all major heights to know (manual)
  /*
  // record min and max somehow? or just test enough in the final project to know what to set min and max to
  */

  // PIR and sonar setup
  pinMode(PIRPIN, INPUT);
  pirSonarDelay.start(PIRSONARDELAYTIME);
  pinMode(PPLSONARPIN, INPUT);
  /*
  // calibrate the max and min distance; 6 will always be min bc of restraint
  but also register the true max range to find the middle? i feel my own measurements is fine tho
  */
  // pirDelay.start(PIRDELAYTIME); // starts the delay, tech i want it to start after PIR is read once for the first time? [**maybe i run the whole sensor reading once in setup?]
  Serial.println("1 minute initialization");
  bufferedOut.connect(Serial);
    // make delay 60000 (1min) for final code
    // may need to increase delay init to 1.5min or smth bc it seems like it doesnt read the initial times
  delay(5000); // initialize pir sensor: can change to a one-shot timer to not do a PIR reading/not leave set-up/start loop until the PIR has initialized so everything else can still set-up

  // capsense setup
  // capSenseDelay.start(CAPSENSEDELAYTIME);

  magentaIncDelay.start(INCDELAY);
  // cyanIncDelay.start(INCEDELAY);
  yellowIncDelay.start(INCDELAY);
  waterIncDelay.start(INCDELAY);
  // start with a switchSystemState() function until button is pressed so that i can hold everything in place to calibrate anything?
}

void loop() {
  // maybe init speed vars here instead of global bc they arent changes anywhere else rly that cant just be changed in the loop? unless it matters to extreme cases

  // DEBUGGING/SHUTOFF AIDS
  bufferedOut.nextByteOut(); // call at least once per loop to release chars
  loopTimer.check(bufferedOut); // send loop timer output to the bufferedOut
  manualSystemSwitch(); // see if manually pausing the program with button / turning back on (pauses sensor reads which snowballs in slowing rest of program)
  waterLevelShutOff(); // checks for water level too high when program is running

  // BLOCKING DELAY CHECKS (if not run already in functions)
  // socialDrainBlockDelay.justFinished(); // must run this each loop even if delay not set yet
  // lonelyBlockDelay.justFinished();
  if(extremeBlockDelay.justFinished()){ // only true once immediately after finishing if not repeated
    socMaxActive = false; // once just finished, set these all back to false so they can be set true again later and not mess w active block delay options
    // socMinActive = false;
    // hydMaxActive = false;
    // hydMinActive = false;
    // creMaxActive = false;
    // creMinActive = false;

    // restart all sensor delays that were turned off during extreme state
    // pirDelay.start(PIRDELAYTIME);
    pirSonarDelay.start(PIRSONARDELAYTIME);
    // capSenseDelay.start(CAPSENSEDELAYTIME);
    // waterSonarDelay.start(WATERSONARDELAYTIME); // keep on always
    floatDelay.start(FLOATDELAYTIME);
    bufferedOut.println("Extreme case finished.");
  }
  // fill in all blocking delay checks on extreme cases

  // SENSOR READINGS
    // when programRunning==false; the sensor delays are stopped so these give their default/non-effect values
  // pirSonarInfo = readPIRSonar();
  readPIRSonar(); // updates pirSonarInfo to be the right values
  // capSenseVal = readCapSense();
  waterSonarDistancemm = readWaterSonar();
  floatDiff = readFloat(); // for now, temp

    // here is where it matters if programRunning is true/false directly to control speed
      // to keep the global vars at their last state, have to force speeds to 0 instead of functions
  if(programRunning){
    if(!extremeBlockDelay.isRunning()){ // more frequent true, normal system state
      // UPDATE VARIABLE BEING STATES
      // when programRunning==false, sensor delays r on defaults so vars SHOULD NOT be updated (make sure to code this in)
      updateSocialize(floatDiff);
      // updateHydrate(waterSonarDistancemm);
      updateCreate(floatDiff);

      // UPDATE PUMP SPEEDS
      magentaSpeed = setMagentaPumpSpeed(); // no delays in these funcs so fine in if-else
      // cyanSpeed = setCyanPumpSpeed();
      yellowSpeed = setYellowPumpSpeed();
      waterSpeed = MINPUMPSPEED*2; // empirical decision of what the basic removal of water speed should be
      removeWater = true;
    }
    else{ // extreme system state
      // extreme case is active - only one case can be true at any given time
      // aka extremeBlockDelay.isRunning()
      if(socMaxActive){
        // set socialize at max behaviors
        magentaSpeed = 0;
        // cyanSpeed = 0;
        yellowSpeed = 0;
        waterSpeed = 255;
        removeWater = true;
      }
      /*
      else if(socMinActive){
        magentaSpeed = 0;
        // cyanSpeed = 0;
        yellowSpeed = 0;
        waterSpeed = 255;
        removeWater = false;
      }
      else if(hydLowActive){ // case for LOW water level
        magentaSpeed = 0;
        // cyanSpeed = 0;
        yellowSpeed = 0;
        waterSpeed = 255;
        removeWater = false;
      }
      else if(hydHighActive){ // case for HIGH water level
        magentaSpeed = 0;
        // cyanSpeed = 0;
        yellowSpeed = 0;
        waterSpeed = 255;
        removeWater = true;
      }
      else if(creMaxActive){
        magentaSpeed = 0;
        // cyanSpeed = 0;
        yellowSpeed = 255;
        waterSpeed = 0;
        removeWater = true;
      }
      else if(creMinActive){
        magentaSpeed = 255;
        // cyanSpeed = 255;
        yellowSpeed = 0;
        waterSpeed = 0;
        removeWater = true;
      }
      */
      else{
        // if none of the extremes were active, smth is just off with the program calculations here
        // should prob turn on an LED or smth to signal that theres a missing Active bool turned to true when extremeBlockDelay was started
        magentaSpeed = 0;
        // cyanSpeed = 0;
        yellowSpeed = 0;
        waterSpeed = 0;
        removeWater = true;
      }
    }
    // if(extremeActive){
      // if socializeMaxRemoveDelay.isRunning{waterSpeed = 255; removeWater = true;} // if justFinished(), then start Max add delay?, note the reversal time to change polarity has to be accounted for
      // else if socializeMaxAddDelay.isRunning{waterSpeed = 255; removeWater = false;}
      // if socializeMinRemoveDelay.isRunning{waterSpeed = 255; removeWater = true;}
      // else if socializeMinAddDelay.isRunning{waterSpeed = 255; removeWater = false;}
      // if hydrateMaxRemoveDelay.isRunning{waterSpeed = 255; removeWater = true}
      // if hydrateMinAddDelay.isRunning{waterSpeed = 255; removeWater = false;}
      // yellow min/max settings only affect M/C pumps to bring them to max or 0 briefly while yellow is on or off appropriately, no affect on removing or adding water
    // } // can extremeActive change at all when others are triggered? can it go false when the extreme case block delays are done? like if any are true justFinished() then extremeActive = false?
  }
  else{
    magentaSpeed = 0; // pull down speed when program is paused/not running (programRunning==false)
    // cyanSpeed = 0;
    yellowSpeed = 0;
    // also slow down water removal/add if it was running
    waterSpeed = 0;
  }

  // RUN PUMPS
  runMagentaPump(magentaSpeed);
  // runCyanPump(cyanSpeed);
  runYellowPump(yellowSpeed);
  waterChange(waterSpeed, removeWater); // remove water constantly at a small amt; removeWater changes depending on min/max extremes but is normally true (for regular draining)

  // timered serial prints (can i do it thru bufferedOut?) that send data to raspberry pi thru serial ports
  // Serial.print("Socialize,");
  // Serial.print(socialize);
  // Serial.println(",");
  // repeat for each var [note the time prints take in the loop..., have function and delay print outs only every few seconds to rpi to capture a sample]
}

// --------SYSTEM PAUSE--------
// handling pauses of the program and potential resets of prior states (maybe i need to write out to a file the last system state)
// blocking delay on all functions - still need to make sure justFinished always runs each loop? --&gt; stops all the other delays so their test if states dont pass
void manualSystemSwitch(){
  // use a button w pull up resistor to read a pin repeatedly to see if its been pressed and program need to be brought to 0 slow down and set block delay
  // adapted code from arduino button example and elegoo manual
  int buttonState = digitalRead(PAUSEBUTTON);

  // using built in input pullup resistor, opposite logical (closed when LOW/0)
  if(!buttonState){ // just avoid clicking a bunch
    delay(200); // debounce; blocking delay but program is changing from on/off so its fine
    switchSystemState();
  }
}

void waterLevelShutOff(){
  // detect water level -&gt; but also stop program here so it can't detect a new water level after it has detected it once so the program cant start again without the button press
  
  /*
  if(programRunning){ // only detect during program running, no delay because i want the readings asap on water level overflow or too high level
    int waterDetected = digitalRead(WATERDETECTPIN); // prob an analog reading tho so threshold below and add in a recalibration in the switchSYstemState() on
    
    if(waterDetected){ // don't accidentally turn on again if the program was off
      switchSystemState(); // causes program to turn off so this will also stop reading and only the button detection can turn on the program again
    }
  }
  */
  return;
}

void switchSystemState(){
  if(programRunning){
    programRunning = false; //!programRunning
    // pirDelay.stop();
    pirSonarDelay.stop();
    // capSenseDelay.stop();
    waterSonarDelay.stop();
    floatDelay.stop();
    // keep pump delays on bc theyll need to be set down to 0
    // force down values elsewhere in program
  }
  else{
    programRunning = true; // !programRunning
    // pirDelay.start(PIRDELAYTIME);
    pirSonarDelay.start(PIRSONARDELAYTIME);
    // capSenseDelay.start(CAPSENSEDELAYTIME);
    waterSonarDelay.start(WATERSONARDELAYTIME);
    floatDelay.start(FLOATDELAYTIME);
    // values will no longer be forced down in loop
    /* NOTE FOR WATER LEVEL SENSOR EMERGENCY SHUT OFF
    // insert calibration code of the water detector used (if its a switch then theres no need, but if its resistance based water level then calibrate)
    */
  }
}

// --------SENSORS--------
void readPIRSonar(){
  // bufferedOut.println(socialize);
  // read PIR and capsense at the same time
  if(pirSonarDelay.justFinished()){
    pirSonarDelay.repeat();
    int pirState = digitalRead(PIRPIN);
    int distance = analogRead(PPLSONARPIN) * 2; // inches, distance
      // 5V yields ~9.8mV/in, (Vcc/512) per inch
      // so max analog 1024 is 2in; mult 2??? - have to test output
    // bufferedOut.println(pirState);
    pirSonarInfo[0] = pirState;
    pirSonarInfo[1] = distance;
    // int readings[2] = {pirState, distance};
    bufferedOut.println(pirSonarInfo[0]);
    // return readings;
    bufferedOut.println(socialize);
  }
  else{
    // int readings[2] = {-1,-1};
    // return readings;
    pirSonarInfo[0] = -1;
    pirSonarInfo[1] = -1;
  }
  
  // return;
}

/*
int readPIR(){ // focus end wk6
  
  // 1) Detect motion (hi or lo?)
  // 2) Count consecutives of hi/lo
  // 3) return consecutive # and type
  
  // NOTE: need to distinguish old and new readings if updateSocialize keeps reading an old reading? (or just let it process that for the particular time)
  if(pirDelay.justFinished()){
    pirDelay.repeat();
    // code from https://mechatronicslearning.com/how-to-use-pir-sensor-with-arduino-beginners-guide/
    int pirState = digitalRead(PIRPIN); // maybe the ver w capacitance as threshold i want to do repeat mode (refreshes time delay and nonreading delay each time a motion is detected anew)
      // tho repeat means high can be repeat detected relatively quickly but lows won't be detected til after the timedelay+nonreaddelay (~6-8s)
      // reading pir state w single trigger would mean new pir detection only every 6-8s (how do i incorporate into the program updating variables?)
    // bufferedOut.println(pirState);
    return pirState; // 0 is false/low, 1 is high/true
    // read the PIR sensor consecutives
    // NOTE: pir sensor needs an initialization period (~1min)
    // NOTE: pir sensor has a stay-high period (min ~3-5sec depend on setting) AND a non-reading time (~3sec)
      // account for this in a time delay so the pir isn't attempted to read again when no change or reading could occur
  }
  else{
    return -1; // need to signal no new reading, may remove if i use in conjunction with capacitive touch sensor (so one interaction could improve or get worse if the distance of the motion that was originally detected is changing)
  }
}
*/

int readWaterSonar(){ // going to be more intricate in calculating so. yeah
  /*
  1) calculate previous net water level change from base level [decide which is more relevant to use, prob base thinking of it is a neutral/balanced state]
  2) return net water level change from base/neutral level [discount removal due to periodic ridding? or shift to have removal only due to excess water addition?]
  */
  // how to read this; simplest way is directly on a sensor but water sensors r tricky...
  // hrlv shortrange mb1644
  if(waterSonarDelay.justFinished()){
    waterSonarDelay.repeat();
    int distance = (analogRead(WATERSONARPIN) * 6) - 300; // directly from doc
    return distance;
  }
  else{
    return 0; // limit of mb1644 supposedly should give a min read of 2cm, so 0 isn't possible in theory unless smth weird happens
  }
  // measuring how much dye is added approximately and how much dye removed, *mathematical calculation*
}

int readFloat(){ 
  /*
  1) Read floating analog pin
  2) randomly choose threshold in float analog range
  3) measure float value difference from threshold (+/0 is counted above threshold, - is counted below)
  4) return the difference
  */
  if(floatDelay.justFinished()){
    floatDelay.repeat();
    int floatThreshold = random(0,1024); // possible values for analog input measure ; (incl, excl); need a val 0 to 1023
    int floatValue = analogRead(FLOATPIN); // current measured value for floating pin
    int floatDifference = floatValue - floatThreshold; // a value -1023 to 1023 possible, 0 is neutral state but not above threshold either

    // bufferedOut.print("Float Difference: ");
    // bufferedOut.println(floatDifference);
    return floatDifference;
  }
  else{
    return 1024; // would need like 1024 or smth as the return if i don't want to reuse an old val tho here i think i would; use floatDiff global var if i want to reuse the last reading
  }
  // check the Float threshold randomization
}

// --------METAPHORICAL VARIABLES--------
void setExtremeState(int delayTime){
  extremeBlockDelay.start(delayTime);
  // pirDelay.stop();
  pirSonarDelay.stop();
  // capSenseDelay.stop();
  // waterSonarDelay.stop(); // dont use, never stop sonar bc itll be used to determine length of extreme state
  floatDelay.stop();
}

int getTimeFromVolume(int waterRatio){
  // get the time in ms needed to move a volume of water based on the current water level
  // int waterLvl = analogRead(WATERSONARPIN);
  // int waterLvl = waterLvl*CONVERSION; // to cm
  // water level is calculated from reversing the distance (max depth - measured depth)
  // int waterLvl = MAXDEPTH - waterLvl;
  // mapping of water volume --&gt; running at 255 is max flow rate (100mL/min)
    // or 1.7mL/sec approximately (or underestimate a little)
  // need to get rid of a certain volume of the height but that relies on knowing the size of tank
  // otherwise the only way to properly add/drain based on height is to use the sonar sensor
  int runTime = 5000; // ms, going to be a measurement somehow
    // delay kept is a do volume base but i need final container to know
    // use booleans if im changing state based on sonar rangefinder (until it reaches the desired water level regardless of volume)
  return runTime;
}

void updateSocialize(int floatValue){
  /*
  1) collect various sensor info to interpret into the variables
  2) range social as 0 to 255 or base speed (for pump pwm) to max 255
  3) basic behavior: hi turns on the pump, lo turns off the pump so maybe just create value range and then map later to 0 to 255?
  */
  // if(socialDrainBlockDelay.isRunning()){ // additional conditions: &amp;&amp; drainFinished (&amp;&amp; any other things that have to run before socialize is updated again r finished too)
  //   return; // don't update socialize, leave it at its last value which was set as slightly below base before
  // }
  // if(lonelyBlockDelay.isRunning()){ // additional conditions: &amp;&amp; drainFinished ^^
  //   return; // don't update socialize, leave it as its last value which can go up to maybe 10% of abse
  // }
  // if (extremeBlockDelay.isRunning()){
  //   return;
  // }

  // max increment
  int maxChange = 100; // avoid floats bc mpa() uses integer math

  // PIR state 75% change or 3/4
  // closePplDistance, midPplDistance
  /*
  HI
    close = ++
    far = --
  LO
    close = -
    far = +
  */
  if (pirSonarInfo[0] &gt; 0) {
    // true, non-zero, high
    socialize += (maxChange * 3) / 4; // FOR TESTING, REMOVE ONCE SONAR IS INCLUDED
    /* ADD BACK WITH SONAR
    if(pirSonarInfo[1] &gt; midPplDistance){ // ignored
      socialize -= (maxChange * 3) / 4;  
    }
    else{ // interacting w friends
      //closer than mid distance
      socialize += (maxChange * 3) / 4;  
    }  
    */
  }
  else if (pirSonarInfo[0] == 0){ // low
    socialize -= (maxChange * 3) / 8; //  FOR TESTING, REMOVE ONCE SONAR INCLUDED
    /* ADD BACK WITH SONAR
    if(pirSonarInfo[1] &gt; midPplDistance){ // just passing strangers
        socialize += (maxChange * 3) / 8;  // half the effect of a motion interaction
    }
    else{ // a little awkward/crowded
      //closer than mid distance
      socialize -= (maxChange * 3) / 8;
    }
    */
  }
  // else{ // negative val (not high or low reading), and any other strange things
  //   // no new reading, no change from PIR to the socialize
  // }

  // modify socialize based on water level calc (or sensor?)
  // 15% change --&gt; 3/20
  /*
  if(sonarDistance &gt; midWaterDist &amp;&amp; sonarDistance &lt; distanceMax){
    socialize += (maxChange *3) / 20; // herd bathroom behavior lol
  }
  else if(sonarDistance &lt; midWaterDist &amp;&amp; sonarDistance &gt; distanceMin){
    socialize -= (maxChange *3) / 20; // need a drinky
  }
  // else{
  //   // below min accepted or above max accepted, or middle water range neutral
  // }
  */

  // modify socialize based on the floating input state
  // 10% change --&gt; random chance increase or decrease if float is above threshold (if not over threshold, no effect)
  if (floatValue &gt; 0 &amp;&amp; floatValue &lt; 1024){ //pos value that isn't over range possible
  // floatValue - floatThreshold = floatDiff, if + means thats floatVal &gt; floatThresh [excluding 0 as a neutral special interpret ig]
    if(random(0,2)){ // (incl, excl)
      // 0 or 1 will be read true or false
      // 1 is true
      socialize += (maxChange / 10); // pos effect on socialize decided; presume creativity has made connections or smth, or spontaneous activity
    }
    else{
      // 0, false
      socialize -= (maxChange / 10); // neg effect on socialize; presume creativity keeping you cooped up working
    }
  } // else floatDiff has no effect on socialize neutral or otherwise; maybe neutral will have a smaller pos/neg effect chance like needing to socialize to find inspo; otherwise stagnate
  
  // constrain the socialize value within a desired range --&gt; note extremes if hitting the bounds in order to reset!!!****** NOTE
    // need to work out these bounds better bc itll take awhile for the program to get up to doing anything, maybe a smaller range? like max 300 for now
  if (socialize &gt; SOCIALIZERANGE) { // maxChange 100 --&gt; 30 times of max 100 increments to get to extreme case --  a total range of 3000 [may make more sense to start at 1000 or less and have 0 be min]
    // upper bound
    // sociallyDrained = true; // global, needs to be known by other functions too
      //***CHANGES BACK TO FALSE AFTER BLOCKING DELAY IN MAGENTA PUMP FUNCTION? --&gt; or block delay here rather than if-else state w bools? magenta pump will just stay at 0 w this socialize val
      // does it make more sense to block this function here from updating socialize?
    bufferedOut.println("Socialize max extreme set");
    socialize = (BASESOCIALIZE * 9) / 10; // reduce to slightly below base 90%; -&gt; a boolean should indicate that its entering an extreme state and allow for block delay to start (also quickly returns this func w top if state)
    const int SOCMAXDELAYTIME = (INCDELAY*255*2) + 5000;
    socMaxActive = true;
    // extremeBlockDelay.start(SOCMAXDELAYTIME);
    // // stop all sensors so they dont affect the variables by chance and run faster
    // pirDelay.stop();
    // // capSenseDelay.stop();
    // // waterSonarDelay.stop();
    // floatDelay.stop();
    setExtremeState(SOCMAXDELAYTIME);
    // socialDrainBlockDelay.start(SOCIALDRAINBLOCKTIME);
    // when hitting the max, see it as drained social battery - pump actions as follows for this state
      // magenta pump stops/slows to 0 speed for a certain length of time [create blocking delay timer]
      // reset socialize back to base level (or a little less than base level to show its back from an abnormal state)
      // other pumps can continue to run, it may also contribute to a slightly higher value on drinking more for instance?
      // removes water to visually show significant drain (this will cause the water level sensor to indicate need for more cyan/hydrate naturally while magenta is blocked^^)
      // add some water back to make sure its somewhat at average level but still below
  }
  else if (socialize &lt; 0) { // SOCIALIZERANGE - SOCIALIZERANGE = 0
    // hit the lower bound
    socialize = BASESOCIALIZE / 10; // it learned some self love or smth
    // extremeBlockDelay.start(SOCMINDELAYTIME);
    /*
    const int SOCMINDELAYTIME = (INCDELAY*255*2) + 5000;
    socMinActive = true;
    setExtremeState(SOCMINDELAYTIME);
    */

    // lonelyBlockDelay.start(LONELYBLOCKTIME);
    // min (loneliness) state - pump actions as follows
      // magenta pump already stopped/not doing anything if its nearing here
      // stagnate?, increase cyan pump? maybe trigger lowering the yellow creat threshold (get thru struggle w creating/VENTING)**
      // i can only think of draining again but maybe make it more significant drainage compared to draining social battery?
      // add back some water but make sure water level is Below state?
  }
  // bufferedOut.print("Socialize: ");
  // bufferedOut.print(socialize);
  // bufferedOut.print(" | ");

  // return socialize;
  // based on the sensors, update socialization variable (ultimately magenta pump, but multiple sensors can affect it)
}

void updateHydrate(int sonarDistance){
  // take direct measure similar to float; calculate a net change
  /*
  // distanceMin and distanceMax are the extremes to measure distance TO the water top (not actual water level itself)
  // water level as the base level is unaffected by any other behavior... maybe
  if(sonarDistance &lt;= 0){
    // non-reading (no new water level)
    return; // no new value to hydrate, just keep last value
  }

  hydrate = sonarDistance; // will map based on min/max in setSpeed

  if(sonarDistance &gt; farthestDistanceToWater){ // low water level
    // add in +/- error?
    hydLowActive = true;
    setExtremeState(HYDLOWDELAYTIME); // **NOTE: change to reading just sonar sensor to get water down
  }
  else if(sonarDistance &lt; closestDistanceToWater){ // high water level
    hydHighActive = true;
    setExtremeState(HYDHIGHDELAYTIME);
  }
  */
  return;
  // based on sensors, update hydration var (cyan)
}

void updateCreate(int floatValue){
  // int maxChange = 100;

  if(floatValue &lt;= ANALOGMAX){
    create = floatValue; // set create to the new float difference read
  }
  // else floatVal is 1024, a nonpossible difference value (out of range), don't change anything abt create value, but do allow it to be changed by other sensors still if they have new vals
    // create stays the same as it was before

  // PIR 10% influence (with sonar)
  // if(pirSonarInfo[0] &gt; 0){
  //   create -= floatValue / 10; // 10% decrement effect b/c busy [changes based on capsense when i get there]
  // }
  // else if(pirSonarInfo[0] == 0){
  //   create += floatValue / 10; // 10% increase effect b/c not busy [changes based on capsense]
  // }
  // else{-1, no effect on vars}
  if (pirSonarInfo[0] &gt; 0) {
    // true, non-zero, high
    if(pirSonarInfo[1] &gt; midPplDistance){ // ignored
      create += floatValue / 10; // time to create, vent art increase?
    }
    else{ // interacting w friends
      //closer than mid distance
      create -= floatValue / 20; // busy, tho lesser bc motivated partially by friends
    }  
  }
  else if (pirSonarInfo[0] == 0){ // low
  if(pirSonarInfo[1] &gt; midPplDistance){ // just passing strangers
      create += floatValue / 10;  // time, maybe a little curiosity
    }
    else{ // a little awkward/crowded
      //closer than mid distance
      create -= floatValue / 10; // not comfortable here
    }
  }

  // WATER LVL 10% influence
  /*
  if(sonarDistance &lt; (midWaterDistance+10) || sonarDistance &gt; (midWaterDistance-10)){
    create += floatValue / 10; // sufficient hydration and not needing to pee, time and energy to art
  }
  else if(sonarDistance &lt; distanceMax &amp;&amp; sonarDistance &gt; distanceMin){
    create -= floatValue / 10; // either need to drink or pee
  }
  // else{
  //   // below min accepted or above max accepted, or middle water range neutral
      // or 0 and no new measure to update anything
  // }
  */

  // FLOAT 80% influence 
    // the other sensors essentially indirectly reflect changing the threshold of the original floatDiff reading
  // idk if ill have these be extreme cases yet, like max could be going overly creative hike and focuses on nothing else (ie: stops cyan and magenta b/c hyperfocus)
    // no creativity min can reflect trying to find inspo by adding a little to the other functions?
  // add in extreme cases only after everything is integrated since this has more effect across the other functions [just save xtreme after all else]
  if(create &gt; ANALOGMAX){ // only the influence of the other sensors can get this over limit
    create = ANALOGMAX; // max possible floatDiff value for mapping
    /*
    const int HYDMAXDELAYTIME = (INCDELAY*255*2) + 5000;
    hydMaxActive = true;
    setExtremeState(HYDMAXDELAYTIME);
    */
    // will cause other pumps to stop running bc of hyperfocus
  }
  else if(create &lt; -ANALOGMAX){
    create = 0; // min possible floatDiff value is -1023; TEMP: to 0 just to have it not run, but this is a specific extremity case
    // will cause other pumps to get a slight boost in value in search of inspo
    /*
    const int HYDMINDELAYTIME = (INCDELAY*255*2) + 5000;
    hydMinActive = true;
    setExtremeState(HYDMINDELAYTIME);
    */
  }
  else if(create &lt;= 0){
    create = 0; // neutral or non-overthreshold state does not run the pump; non-extreme min
    // no special effect, just smth to help define mappings of speed later
  }
  /*
  pos float diffs increase create, neg float diffs decrease create ? or just keep it off?
  create = floatDiff;
  
  water level:
  + (need to pee, no time to art): subtract from floatDiff/create
  neut (proper hydration): increase floatDiff/create
  - (not hydrated, need energy to art): subtract from floatDiff/create
  
  pir:
  hi (busy, with capsense-adjust further): subtract from floatDiff/create 
  lo (not busy): add to floatDiff/create
  capsense edit:
  hi
    distant add floatdiff (vent?)
    close subtract floatdiff (busy?)
  lo
    distant add floatdiff (free time)
    close subtract floatdiff (awkward proximity, restraint)
  */
  
  // based on float solely? or some sensor influence, update creativity (threshold?) (yellow)
}

// --------PUMPS--------
// ---SPEED---
int setMagentaPumpSpeed(){
  /*
  1) interpret socialize var --&gt; map to working speed
  2) set pump to run w progressive increase alongside rest of pumps w incremental increase?
  */
  int speed = 0; // off, 85 is minimum for on
  speed = map(socialize, 0, SOCIALIZERANGE, 0, 255); // map the values into accepted ranges for affecting the pump running
  if(speed &lt; MINPUMPSPEED){ // minimum pump speed to run
    // 1/3 of max pump speed, also minimum speed to see any water flowing
    speed = 0; // will pull the pump to 0 regardless if it goes below here because its useless energy wasted on putting it below that and seeing nothing but maybe getting noise
  }
  // bufferedOut.print("Speed: ");
  // bufferedOut.print(speed);
  // bufferedOut.print(" | ");
  return speed;
}

int setCyanPumpSpeed(){
  /*
  int speed = 0;
  if(hydrate&lt;=0){
    // for whatever reason
    return speed; // 0
  }
  if(hydrate &lt; midWaterDist){
    // closer water distance means higher level
    return speed; // 0, no adding cyan when not thirsty (enough water)
  }
  else{
    speed = map(hydrate, midWaterDist, distanceMax, MINPUMPSPEED, 255);
    // should be larger water dist for more speed
    return speed;
  }
  */
  return;
}

int setYellowPumpSpeed(){
  int speed = 0; // off, 85 is minimum for on
  if(create &lt;= 0){
    return speed; // 0
  }
  else{
    speed = map(create, 1, ANALOGMAX, MINPUMPSPEED, 255); // map the values into accepted ranges for affecting the pump running
      // increasing min pump speed just bc the yellow rate seems not to be as significant for 85 compared to how magenta pump runs
    /*if(speed &lt; MINPUMPSPEED){ // minimum pump speed to run ; shouldnt happen w mapping
      // 1/3 of max pump speed, also minimum speed to see any water flowing
      speed = 0; // will pull the pump to 0 regardless if it goes below here because its useless energy wasted on putting it below that and seeing nothing but maybe getting noise
    }*/
    // bufferedOut.print("Speed: ");
    // bufferedOut.print(speed);
    // bufferedOut.print(" | ");
    return speed;
  }
}

// ---RUNNING---
// to turn into a function w parameters per pump, i can do pointer parameters int &amp;engageVal [change that variable directly] - my calls just have to be precise
// void runPump(int speed, int &amp;pumpPin, int &amp;engageVal, millisDelay &amp;incDelay){} // my ish is the object... crossing libraries is my doom, pointer to obejct bc don't wanna make a copy, NEED to use it as is
void runMagentaPump(int speed){
  // allow the pump to constantly run and adapt its speed increase/decrease based on the speed input it gets (so it changes toward a certain scope regardless of what is was trying to get to before)

  // constrain speed
  if(speed &gt; 255){
    speed = 255; // pump pwm cant be more than 255
  }
  else if (speed &lt; 0){
    speed = 0; // pump pwm cant be less than 0 [basically an unsigned byte]
  }

  // will the pump be constrained to 255 and 0 this way tho? speed has to be constrained then
    // constraining speed, this if state should be able to constrain engageVal to 0 and 255 as well
  int increment;
  if(magentaEnVal &lt; speed){
    // if the current state of the pump speed is less than the speed it is given to reach, keep incrementing
    increment = 1;
  }
  else if(magentaEnVal &gt; speed){
    // if current state of pump speed is greater than speed intended, start decrementing
    increment = -1;
  }
  else{
    // engageVal is same as intended speed, means the program shouldnt increment anymore, but itll also stop the delay later so this can be set 0
    increment = 0;
  }

  if(magentaIncDelay.justFinished()){
    magentaIncDelay.repeat();
    magentaEnVal += increment;
    // bufferedOut.print("Magenta Engage Val: ");
    // bufferedOut.println(magentaEngageVal);
    analogWrite(MAGENTAPIN, magentaEnVal); //**should i adjust to have 0 increment not calculate or keep the delay working to keep a somewhat consistent pump rate
      // i can adjust the delay here to change how fast i want the pump responding to its sensory-variables
    // bufferedOut.print("Engage Val: ");
    // bufferedOut.println(magentaEnVal);
  }
  // else{
  //   bufferedOut.println();
  // }
}

void runCyanPump(int speed){
    // allow the pump to constantly run and adapt its speed increase/decrease based on the speed input it gets (so it changes toward a certain scope regardless of what is was trying to get to before)

  // constrain speed
  if(speed &gt; 255){
    speed = 255; // pump pwm cant be more than 255
  }
  else if (speed &lt; 0){
    speed = 0; // pump pwm cant be less than 0 [basically an unsigned byte]
  }

  // will the pump be constrained to 255 and 0 this way tho? speed has to be constrained then
    // constraining speed, this if state should be able to constrain engageVal to 0 and 255 as well
  int increment;
  if(cyanEnVal &lt; speed){
    // if the current state of the pump speed is less than the speed it is given to reach, keep incrementing
    increment = 1;
  }
  else if(cyanEnVal &gt; speed){
    // if current state of pump speed is greater than speed intended, start decrementing
    increment = -1;
  }
  else{
    // engageVal is same as intended speed, means the program shouldnt increment anymore, but itll also stop the delay later so this can be set 0
    increment = 0;
  }
  
  if(cyanIncDelay.justFinished()){
    cyanIncDelay.repeat();
    cyanEnVal += increment;
    // bufferedOut.print("Magenta Engage Val: ");
    // bufferedOut.println(magentaEngageVal);
    analogWrite(CYANPIN, cyanEnVal); //**should i adjust to have 0 increment not calculate or keep the delay working to keep a somewhat consistent pump rate
      // i can adjust the delay here to change how fast i want the pump responding to its sensory-variables
    // bufferedOut.print("Engage Val: ");
    // bufferedOut.println(cyanEnVal);
  }
  // else{
  //   bufferedOut.println();
  // }
}

void runYellowPump(int speed){
    // allow the pump to constantly run and adapt its speed increase/decrease based on the speed input it gets (so it changes toward a certain scope regardless of what is was trying to get to before)

  // constrain speed
  if(speed &gt; 255){
    speed = 255; // pump pwm cant be more than 255
  }
  else if (speed &lt; 0){
    speed = 0; // pump pwm cant be less than 0 [basically an unsigned byte]
  }

  // will the pump be constrained to 255 and 0 this way tho? speed has to be constrained then
    // constraining speed, this if state should be able to constrain engageVal to 0 and 255 as well
  int increment;
  if(yellowEnVal &lt; speed){
    // if the current state of the pump speed is less than the speed it is given to reach, keep incrementing
    increment = 1;
  }
  else if(yellowEnVal &gt; speed){
    // if current state of pump speed is greater than speed intended, start decrementing
    increment = -1;
  }
  else{
    // engageVal is same as intended speed, means the program shouldnt increment anymore, but itll also stop the delay later so this can be set 0
    increment = 0;
  }
  
  if(yellowIncDelay.justFinished()){
    yellowIncDelay.repeat();
    yellowEnVal += increment;
    // bufferedOut.print("Magenta Engage Val: ");
    // bufferedOut.println(magentaEngageVal);
    analogWrite(YELLOWPIN, yellowEnVal); //**should i adjust to have 0 increment not calculate or keep the delay working to keep a somewhat consistent pump rate
      // i can adjust the delay here to change how fast i want the pump responding to its sensory-variables
    // bufferedOut.print("Engage Val: ");
    // bufferedOut.println(yellowEnVal);
  }
  // else{
  //   bufferedOut.println();
  // }
}

// --------WATER HANDLING--------
// NOTE: need to regularly REMOVE water from the program each loop to avoid overflow (only blocked when any of the min/max functions besides create happens)
void waterChange(int speed, bool reversePolarity){
  // constrain speed
  if(speed &gt; 255){
    speed = 255; // pump pwm cant be more than 255
  }
  else if (speed &lt; 0){
    speed = 0; // pump pwm cant be less than 0 [basically an unsigned byte]
  }

  // set speed to the appropriate wire based on polarity setting
  int addInSpeed;
  int rmvInSpeed;
  if(reversePolarity){
    if(waterAddInVal &gt; 0){ // if the opposite input is not 0 yet, don't allow current flows
      addInSpeed = 0; // input 1 needs to be 0 b4 reversing polarity to inc input 2
      rmvInSpeed = 0; // no speed change until input 1 is 0
    }
    else{
      addInSpeed = 0;
      rmvInSpeed = speed;
    }
  }
  else{
    if(waterRmvInVal &gt; 0){
      addInSpeed = 0; // no speed change until input 2 is 0
      rmvInSpeed = 0; // input 2 needs to be 0 b4 polarity to reg to inc input 1
    }
    else{
      addInSpeed = speed;
      rmvInSpeed = 0;
    }
  }

  // set the increment for changing input val
  int addIncrement;
  int rmvIncrement;
  // INPUT 2
  if(waterAddInVal &lt; addInSpeed){
    // if the current state of the pump speed is less than the speed it is given to reach, keep incrementing
    addIncrement = 1;
  }
  else if(waterAddInVal &gt; addInSpeed){
    // if current state of pump speed is greater than speed intended, start decrementing
    addIncrement = -1;
  }
  else{
    // engageVal is same as intended speed, means the program shouldnt increment anymore, but itll also stop the delay later so this can be set 0
    addIncrement = 0;
  }
  // INPUT 2
  if(waterRmvInVal &lt; rmvInSpeed){
    // if the current state of the pump speed is less than the speed it is given to reach, keep incrementing
    rmvIncrement = 1;
  }
  else if(waterRmvInVal &gt; rmvInSpeed){
    // if current state of pump speed is greater than speed intended, start decrementing
    rmvIncrement = -1;
  }
  else{
    // engageVal is same as intended speed, means the program shouldnt increment anymore, but itll also stop the delay later so this can be set 0
    rmvIncrement = 0;
  }

  if(waterRmvInVal &gt; 0 &amp;&amp; waterAddInVal &gt; 0){ // shouldnt happen but just in case [both inputs should NOT be going on at the same time]
    // addInSpeed = 0;
    // rmvInSpeed = 0;
    addIncrement = -1;
    rmvIncrement = -1;
    // switchSystemState(); // something wrong w system if both are on, but switchSystemState should happen only when both can be at 0
  }

  if(waterIncDelay.justFinished()){
    waterIncDelay.repeat();
    waterAddInVal += addIncrement;
    waterRmvInVal += rmvIncrement;
    // bufferedOut.print("Magenta Engage Val: ");
    // bufferedOut.println(magentaEngageVal);
    analogWrite(WATERADDIN, waterAddInVal);
    analogWrite(WATERRMVIN, waterRmvInVal); //**should i adjust to have 0 increment not calculate or keep the delay working to keep a somewhat consistent pump rate
      // i can adjust the delay here to change how fast i want the pump responding to its sensory-variables
    // bufferedOut.print("Engage Val: ");
    // bufferedOut.println(yellowEnVal);
  }
}</code></pre></div></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Jett 2025 - Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://n-katty-kat.github.io/ixu-reflected/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://n-katty-kat.github.io/ixu-reflected/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>